"""Utility helpers for session management."""

from __future__ import annotations

from datetime import datetime, timezone
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple

from app.models.auth import SessionInfo


def build_session_cache_key(user_id: str) -> str:
    """Build cache key for a user's sessions."""
    return f"sessions:{user_id}"


def serialize_sessions(sessions: Sequence[SessionInfo]) -> List[dict]:
    """Convert SessionInfo objects to serialisable dicts."""
    return [session.model_dump() for session in sessions]


def deserialize_sessions(raw_sessions: Optional[Iterable]) -> List[SessionInfo]:
    """Convert raw cache payload into SessionInfo objects."""
    if not raw_sessions:
        return []

    sessions: List[SessionInfo] = []
    for item in raw_sessions:
        if isinstance(item, SessionInfo):
            sessions.append(item)
        elif isinstance(item, dict):
            try:
                sessions.append(SessionInfo(**item))
            except Exception:
                continue
    return sessions


def calculate_session_ttl_seconds(session: SessionInfo) -> int:
    """Calculate remaining TTL in seconds for a session."""
    try:
        expires_at = datetime.fromisoformat(session.expires_at)
    except ValueError:
        # Expires_at generated by service; fall back to 1 hour.
        return 3600

    if expires_at.tzinfo is None:
        expires_at = expires_at.replace(tzinfo=timezone.utc)

    now = datetime.now(timezone.utc)
    remaining = (expires_at - now).total_seconds()
    return max(60, int(remaining))


def remove_session_by_id(
    sessions: Sequence[SessionInfo],
    session_id: str
) -> Tuple[List[SessionInfo], Optional[SessionInfo]]:
    """Remove a session by ID from collection."""
    remaining: List[SessionInfo] = []
    removed: Optional[SessionInfo] = None

    for session in sessions:
        if session.session_id == session_id:
            removed = session
            continue
        remaining.append(session)

    return remaining, removed


def sort_sessions_by_last_activity(sessions: Sequence[SessionInfo]) -> List[SessionInfo]:
    """Sort sessions by last activity descending."""
    def _parse_last_activity(value: SessionInfo) -> float:
        try:
            ts = datetime.fromisoformat(value.last_activity)
            if ts.tzinfo is None:
                ts = ts.replace(tzinfo=timezone.utc)
            return ts.timestamp()
        except Exception:
            return 0.0

    return sorted(sessions, key=_parse_last_activity, reverse=True)


def filter_expired_sessions(sessions: Sequence[SessionInfo]) -> List[SessionInfo]:
    """Filter out expired sessions."""
    now = datetime.now(timezone.utc)
    active: List[SessionInfo] = []

    for session in sessions:
        try:
            expires_at = datetime.fromisoformat(session.expires_at)
            if expires_at.tzinfo is None:
                expires_at = expires_at.replace(tzinfo=timezone.utc)
            if expires_at > now:
                active.append(session)
        except Exception:
            continue

    return active


def session_info_from_record(record: Dict[str, Any]) -> SessionInfo:
    """Convert repository record into SessionInfo."""
    def _to_iso(value: Any) -> str:
        if value is None:
            return ""
        if isinstance(value, datetime):
            return value.isoformat()
        return str(value)

    return SessionInfo(
        session_id=_to_iso(record.get("id")),
        user_id=_to_iso(record.get("user_id")),
        tenant_id=_to_iso(record.get("tenant_id")),
        ip_address=record.get("ip_address", ""),
        user_agent=record.get("user_agent", ""),
        created_at=_to_iso(record.get("created_at")) or _to_iso(record.get("last_activity")),
        last_activity=_to_iso(record.get("last_activity")),
        expires_at=_to_iso(record.get("expires_at")),
    )


def sessions_from_records(records: Sequence[Dict[str, Any]]) -> List[SessionInfo]:
    """Convert multiple records to SessionInfo objects."""
    sessions: List[SessionInfo] = []
    for record in records:
        try:
            sessions.append(session_info_from_record(record))
        except Exception:
            continue
    return sessions
